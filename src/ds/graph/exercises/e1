4.1.1 一幅含有V个顶点且不含有平行边的图中至 多 含有多少条边？一幅含有V个顶点的连通图中至少含有多少条边？
    V*(V-1)/2
        每条边都可以和除了自己以外的其它边相连, 并且由于无向, 所以/2
            o-o
            |x|
            o-o
    V-1
        最少的边
            o-o-o

4.1.2 按照正文中示意图的样式（请见图4.1.9）画出Graph的构造函数在处理图4.1.25的tinyGex2.txt时构造的邻接表。
    V=12
    E=16

    0:  5->2->6
    1:  4->8->11
    2:  5->6->0->3
    3:  10->6->2
    4:  1->8
    5:  0->10->2
    6:  2->3->0
    7:  8->11
    8:  1->11->7->4
    9
    10: 5->3
    11: 8->7->1

    无向图
        public void addEdge(int v, int w){
            adj[v].add(w);
            adj[w].add(v);
            this.edge ++;
        }

4.1.3 写一个构造函数，能够深拷贝一副图。
        GraphDuplicateConstructor

4.1.4 写一个hasEdge方法，它接受两个参数v 和 w，如果图有边v-w，返回true，否则返回false
        GraphHasEdge

4.1.5 修改Graph，不允许存在平行边和自环。
    平行边：    o---o
                \-/
    自环：     o
             / \
             \-/

    思路： 在addEdge中加入判断。
        平行边: hasEdge ? return : addEdge
        自环: v == w ? return : continue;

4.1.6 给出一种已填充的邻接表数组，无论怎么调用addEdge都无法实现：
    0-1
    | |
    3—2
    找到一种顺时针的正确的adj:
        0: 3 -> 1   改为 1->3 即为解。
        1: 2 -> 0
        2: 3 -> 1
        3: 0 -> 2

4.1.7 给Graph加一个toString方法。

4.1.8 用union-find实现4.1.2.3中的搜索 (Search.java) API
    用UF重新构建一遍图就得到了想要的

4.1.9 使用dfs(0)处理由Graph构造函数从tinyGex2.txt得到的图，并给出dfs轨迹。同时，画出edgeTo[]所表示的树。
    由Graph构造函数得到的adj：
        0	-> 5-> 2-> 6
        1	-> 4-> 8-> 11
        2	-> 5-> 6-> 0-> 3
        3	-> 10-> 6-> 2
        4	-> 1-> 8
        5	-> 0-> 10-> 2
        6	-> 2-> 3-> 0
        7	-> 8-> 11
        8	-> 1-> 11-> 7-> 4
        9
        10	-> 5-> 3
        11	-> 8-> 7-> 1
    由DFS得到的路径：
                        marked[]    adj[]
        dfs (0)          0 T        0 5 2 6
                         1          1 4 8 11
                         2          2 5 6 0 3
                         3          3 10 6 2
                         4          4 1 8
                         5          5 0 10 2
                         6          6 2 3 0
                         7          7 8 11
                         8          8 1 11 7 4
                         9          9
                        10         10 5 3
                        11         11 8 7 1

         dfs (5)         0 T        0 5 2 6
          check 0        1          1 4 8 11
                         2          2 5 6 0 3
                         3          3 10 6 2
                         4          4 1 8
                         5 T        5 0 10 2
                         6          6 2 3 0
                         7          7 8 11
                         8          8 1 11 7 4
                         9          9
                        10         10 5 3
                        11         11 8 7 1

          dfs (10)       0 T        0 5 2 6
           check 5       1          1 4 8 11
                         2          2 5 6 0 3
                         3          3 10 6 2
                         4          4 1 8
                         5 T        5 0 10 2
                         6          6 2 3 0
                         7          7 8 11
                         8          8 1 11 7 4
                         9          9
                        10 T       10 5 3
                        11         11 8 7 1

           dfs (3)       0 T        0 5 2 6
            check 10     1          1 4 8 11
                         2          2 5 6 0 3
                         3 T        3 10 6 2
                         4          4 1 8
                         5 T        5 0 10 2
                         6          6 2 3 0
                         7          7 8 11
                         8          8 1 11 7 4
                         9          9
                        10 T       10 5 3
                        11         11 8 7 1

            dfs (6)      0 T        0 5 2 6
                         1          1 4 8 11
                         2          2 5 6 0 3
                         3 T        3 10 6 2
                         4          4 1 8
                         5 T        5 0 10 2
                         6 T        6 2 3 0
                         7          7 8 11
                         8          8 1 11 7 4
                         9          9
                        10 T       10 5 3
                        11         11 8 7 1

             dfs (2)     0 T        0 5 2 6
              check 5    1          1 4 8 11
              check 6    2 T        2 5 6 0 3
              check 0    3 T        3 10 6 2
              check 3    4          4 1 8
             2 done      5 T        5 0 10 2
                         6 T        6 2 3 0
                         7          7 8 11
                         8          8 1 11 7 4
                         9          9
                        10 T       10 5 3
                        11         11 8 7 1
             check 3
             check 0
            6 done
            check 2
           3 done
          10 done
          check 2
         5 done
         check 2
         check 6
        0 done

        edgeTo[]:
        i    0   1   2   3   4   5   6   7   8   9   10  11
        v            6   10      0   3               5

        tree:
                   0
                  5
                10
               3
              6
             2

*4.1.10 证明在任意一副连通图中都存在一个顶点，删去它（以及它所相连的所有边）不会影响到图的连通性。
编写一个DFS方法找出这样一个顶点。提示：留心那些相邻顶点全都被标记过的顶点。
    相邻顶点都被标记过的顶点可以被删除，因为已经不需要通过它去访问没到过的顶点（它的邻居都已经是访问过的了）。
    找出这样的一个顶点即可，不需要真的删除它。
    GraphDeleteVertexReserveConnectivity.java

4.1.11 使用算法4.2 BFS，中的bfs(G,0)来处理由Graph构造函数从tinyGex2.txt得到的图，并画出edgeTo[]所表示的树。


-------------------------------------------
    问题                      解决方法
单点连通性                    DepthFirstSearch
单点路径                      DepthFirstPaths
单点最短路径                   BreadFirstPaths
连通性                         CC
检测环                         Cycle
双色问题（图的二分性）           TowColor
-------------------------------------------
4.1.1 一幅含有V个顶点且不含有平行边的图中至 多 含有多少条边？一幅含有V个顶点的连通图中至少含有多少条边？
    V*(V-1)/2
        每条边都可以和除了自己以外的其它边相连, 并且由于无向, 所以/2
            o-o
            |x|
            o-o
    V-1
        最少的边
            o-o-o

4.1.2 按照正文中示意图的样式（请见图4.1.9）画出Graph的构造函数在处理图4.1.25的tinyGex2.txt时构造的邻接表。
    V=12
    E=16

    0:  5->2->6
    1:  4->8->11
    2:  5->6->0->3
    3:  10->6->2
    4:  1->8
    5:  0->10->2
    6:  2->3->0
    7:  8->11
    8:  1->11->7->4
    9
    10: 5->3
    11: 8->7->1

    无向图
        public void addEdge(int v, int w){
            adj[v].add(w);
            adj[w].add(v);
            this.edge ++;
        }

4.1.3 写一个构造函数，能够深拷贝一副图。
        GraphDuplicateConstructor

4.1.4 写一个hasEdge方法，它接受两个参数v 和 w，如果图有边v-w，返回true，否则返回false
        GraphHasEdge

4.1.5 修改Graph，不允许存在平行边和自环。
    平行边：    o---o
                \-/
    自环：     o
             / \
             \-/

    思路： 在addEdge中加入判断。
        平行边: hasEdge ? return : addEdge
        自环: v == w ? return : continue;

4.1.6 给出一种已填充的邻接表数组，无论怎么调用addEdge都无法实现：
    0-1
    | |
    3—2
    找到一种顺时针的正确的adj:
        0: 3 -> 1   改为 1->3 即为解。
        1: 2 -> 0
        2: 3 -> 1
        3: 0 -> 2

4.1.7 给Graph加一个toString方法。

4.1.8 用union-find实现4.1.2.3中的搜索 (Search.java) API
    用UF重新构建一遍图就得到了想要的

4.1.9 使用dfs(0)处理由Graph构造函数从tinyGex2.txt得到的图，并给出dfs轨迹。同时，画出edgeTo[]所表示的树。
    由Graph构造函数得到的adj：
        0	-> 5-> 2-> 6
        1	-> 4-> 8-> 11
        2	-> 5-> 6-> 0-> 3
        3	-> 10-> 6-> 2
        4	-> 1-> 8
        5	-> 0-> 10-> 2
        6	-> 2-> 3-> 0
        7	-> 8-> 11
        8	-> 1-> 11-> 7-> 4
        9
        10	-> 5-> 3
        11	-> 8-> 7-> 1
    由DFS得到的路径：
                        marked[]    adj[]
        dfs (0)          0 T        0 5 2 6
                         1          1 4 8 11
                         2          2 5 6 0 3
                         3          3 10 6 2
                         4          4 1 8
                         5          5 0 10 2
                         6          6 2 3 0
                         7          7 8 11
                         8          8 1 11 7 4
                         9          9
                        10         10 5 3
                        11         11 8 7 1

         dfs (5)         0 T        0 5 2 6
          check 0        1          1 4 8 11
                         2          2 5 6 0 3
                         3          3 10 6 2
                         4          4 1 8
                         5 T        5 0 10 2
                         6          6 2 3 0
                         7          7 8 11
                         8          8 1 11 7 4
                         9          9
                        10         10 5 3
                        11         11 8 7 1

          dfs (10)       0 T        0 5 2 6
           check 5       1          1 4 8 11
                         2          2 5 6 0 3
                         3          3 10 6 2
                         4          4 1 8
                         5 T        5 0 10 2
                         6          6 2 3 0
                         7          7 8 11
                         8          8 1 11 7 4
                         9          9
                        10 T       10 5 3
                        11         11 8 7 1

           dfs (3)       0 T        0 5 2 6
            check 10     1          1 4 8 11
                         2          2 5 6 0 3
                         3 T        3 10 6 2
                         4          4 1 8
                         5 T        5 0 10 2
                         6          6 2 3 0
                         7          7 8 11
                         8          8 1 11 7 4
                         9          9
                        10 T       10 5 3
                        11         11 8 7 1

            dfs (6)      0 T        0 5 2 6
                         1          1 4 8 11
                         2          2 5 6 0 3
                         3 T        3 10 6 2
                         4          4 1 8
                         5 T        5 0 10 2
                         6 T        6 2 3 0
                         7          7 8 11
                         8          8 1 11 7 4
                         9          9
                        10 T       10 5 3
                        11         11 8 7 1

             dfs (2)     0 T        0 5 2 6
              check 5    1          1 4 8 11
              check 6    2 T        2 5 6 0 3
              check 0    3 T        3 10 6 2
              check 3    4          4 1 8
             2 done      5 T        5 0 10 2
                         6 T        6 2 3 0
                         7          7 8 11
                         8          8 1 11 7 4
                         9          9
                        10 T       10 5 3
                        11         11 8 7 1
             check 3
             check 0
            6 done
            check 2
           3 done
          10 done
          check 2
         5 done
         check 2
         check 6
        0 done

        edgeTo[]:
        i    0   1   2   3   4   5   6   7   8   9   10  11
        v            6   10      0   3               5

        tree:
                   0
                  5
                10
               3
              6
             2

*4.1.10 证明在任意一副连通图中都存在一个顶点，删去它（以及它所相连的所有边）不会影响到图的连通性。
编写一个DFS方法找出这样一个顶点。提示：留心那些相邻顶点全都被标记过的顶点。
    相邻顶点都被标记过的顶点可以被删除，因为已经不需要通过它去访问没到过的顶点（它的邻居都已经是访问过的了）。
    找出这样的一个顶点即可，不需要真的删除它。
    GraphDeleteVertexReserveConnectivity.java

4.1.11 使用算法4.2 BFS，中的bfs(G,0)来处理由Graph构造函数从tinyGex2.txt得到的图，并画出edgeTo[]所表示的树。
    tinyGex2:
        0	-> 5-> 2-> 6
        1	-> 4-> 8-> 11
        2	-> 5-> 6-> 0-> 3
        3	-> 10-> 6-> 2
        4	-> 1-> 8
        5	-> 0-> 10-> 2
        6	-> 2-> 3-> 0
        7	-> 8-> 11
        8	-> 1-> 11-> 7-> 4
        9
        10	-> 5-> 3
        11	-> 8-> 7-> 1

            0
        2   5   6
    3   10

*4.1.12 如果v和w都不是根结点，能由BFS计算他们间的距离吗？
    When neither v nor w are at the root, the BFS tree tell us that if they are
    on the same branch, there is a path between v and w of distance equal to the
     number of edges between them in the branch.
    If they are not on the same branch, there is a path between v and w of
    distance Dv + Dw, where Dv is the distance from the root to vertex v and Dw
    is the distance from the root to vertex w.

4.1.13 为BreadthFirstPaths的API添加并实现一个方法distTo()，返回从起点到给定的顶点的最短路径的长度，
    它所需的时间（调用distTo的时间，不包括构建它的时间...）应该为常数。
    BFSDistTo.java

*4.1.14 如果用栈代替队列来实现广度优先搜索，我们还能得到最短路径吗？
    (用栈怎么BFS？
        用两个栈吗：
            栈1没孩子节点直接出栈，有孩子节点存入栈2，直到栈1为空当前层结束，
            从栈2开始继续，将下一层的节点放进栈1。
            两栈都为空时，搜索结束。
        但我都用两个栈了为什么不直接模拟一个队列？
    )

4.1.15 修改Graph的输入流构造函数，允许从标准输入读入图的邻接表（方法类似于Symbo-lGraph），
    如图4.1.26的tinyGadj.txt所示。在顶点和边的总数之后，每一行由一个顶点和它的所有相邻顶点组成。
    GraphAdjConstruct.java

4.1.16 顶点v的离心率是它和离它最远的顶点的最短距离。图的直径即所有顶点的最大离心率，半径为所有顶点的最
    小离心率，中点为离心率和半径相等的顶点。实现以下API，如表4.1.10所示。
    public class GraphProperties
            GraphProperties(Graph G)        构造函数（如果G不连通，抛出异常）
        int eccentricity(int v)             v的离心率
        int diameter()                      G的直径
        int radius()                        G的半径
        int center()                        G的某个中点

4.1.17 图的周长为最短环的长度。如果是无环图，则它的周长为无穷大。为GraphProperties添加一个方法girth()，返回图的周长。
    提示：在每个顶点都进行广度优先搜索。含有s的最小环为s到某个顶点v的最短路径加上从v返回到s的边。
        0
       / \
      1   2
     / \ /
    3   4

>
    queue       0
    v           0
    w           1,2
    ---
    0
    ------------------------------
                0   1   2   3   4
    ------------------------------
    marked      T
    distTo      0
    edgeTo      0
    ------------------------------
>
    queue       1   2
    v           1
    w           3,4 (0)
    ---
    1
    ------------------------------
                0   1   2   3   4
    ------------------------------
    marked      T   T
    distTo      0   1
    edgeTo      0   0
    ------------------------------
>



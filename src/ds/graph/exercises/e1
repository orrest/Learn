4.1.1 一幅含有V个顶点且不含有平行边的图中至 多 含有多少条边？一幅含有V个顶点的连通图中至少含有多少条边？
    V*(V-1)/2
        每条边都可以和除了自己以外的其它边相连, 并且由于无向, 所以/2
            o-o
            |x|
            o-o
    V-1
        最少的边
            o-o-o

4.1.2 按照正文中示意图的样式（请见图4.1.9）画出Graph的构造函数在处理图4.1.25的tinyGex2.txt时构造的邻接表。
    V=12
    E=16

    0:  5->2->6
    1:  4->8->11
    2:  5->6->0->3
    3:  10->6->2
    4:  1->8
    5:  0->10->2
    6:  2->3->0
    7:  8->11
    8:  1->11->7->4
    9
    10: 5->3
    11: 8->7->1

    无向图
        public void addEdge(int v, int w){
            adj[v].add(w);
            adj[w].add(v);
            this.edge ++;
        }

4.1.3 写一个构造函数，能够深拷贝一副图。
        GraphDuplicateConstructor

4.1.4 写一个hasEdge方法，它接受两个参数v 和 w，如果图有边v-w，返回true，否则返回false
        GraphHasEdge

4.1.5 修改Graph，不允许存在平行边和自环。
    平行边：    o---o
                \-/
    自环：     o
             / \
             \-/

    思路： 在addEdge中加入判断。
        平行边: hasEdge ? return : addEdge
        自环: v == w ? return : continue;

4.1.6 给出一种已填充的邻接表数组，无论怎么调用addEdge都无法实现：
    0-1
    | |
    3—2
    找到一种顺时针的正确的adj:
        0: 3 -> 1   改为 1->3 即为解。
        1: 2 -> 0
        2: 3 -> 1
        3: 0 -> 2

4.1.7 给Graph加一个toString方法。

4.1.8 用union-find实现4.1.2.3中的搜索 (Search.java) API
    用UF重新构建一遍图就得到了想要的


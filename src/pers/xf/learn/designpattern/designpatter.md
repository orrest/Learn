# 原则

1. 开闭原则：对拓展开放，对修改关闭
2. 依赖倒置：依赖抽象，降低耦合
3. 单一职责：单一职责、降低耦合
4. 接口隔离：不要使用单一的总接口
5. 迪米特法则：最少知道原则
6. 里氏替换原则：子类父类可以替换，使用方法不变
7. 合成复用原则：使用组合、聚合，避免继承

# 策略模式

策略模式使用的就是面向对象的继承和多态机制，从而实现同一行为在不同的场景下具备不同的实现。

策略模式适用于以下应用场景:
- 针对同一类型问题，有多种处理方式，每一种都能独立解决问题。
- 需要自由切换算法的场景。
- 需要屏蔽算法规则的场景。

策略模式主要包含3个角色
- IStrategy：规定策略或算法的行为。
- Context：用来操作策略的上下文环境，屏蔽高层模块（客户端）对策略、算法的直接访问，
封装可能存在的变化。比如PayStrategy，通过Map封装具体策略映射，这样应用时只需给出指令即可。
- ConcreteStrategy：具体的策略或算法实现。

优点：
- 符合开闭原则
- 避免if...else, switch...case（通过Map）
- 提高安全性

缺点：
- 客户端必须知道所有的策略，并且自行决定使用哪一个策略类。
- 代码中会产生非常多策略类，增加维护难度。

# 模板方法模式

模板方法模式（Template Method Pattern）又叫作模板模式，指定义一个操作中的算法的框架，
而将一些步骤延迟到子类中，*使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤*，
属于行为型设计模式。

模板方法模式实际上封装了一个固定流程，该流程由几个步骤组成，具体步骤可以由子类进行不同的实现，
从而让固定的流程产生不同的结果。它非常简单，其实就是类的继承机制，但它却是一个应用非常广泛的模式。
模板方法模式的本质是抽象封装流程，具体进行实现。

模板方法模式适用于以下应用场景:
- 一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现。
- 各子类中公共的行为被提取出来，集中到一个公共的父类中，从而避免代码重复。

优点:
- 提高代码的复用性。
- 提高代码的可扩展性。
- 把不变的行为写在父类上，去除子类的重复代码，提供了一个很好的代码复用平台，符合开闭原则。

缺点:
- 每一个抽象类都需要一个子类来实现，这样导致类数量增加。
- 由于继承关系自身的缺点，如果父类添加新的抽象方法，则所有子类都要改一遍。

相关内容
- JDK AbstractList
- (注解和模板方法模式有关系吗?)

# 委派模式

委派模式（Delegate Pattern）又叫作委托模式，是一种面向对象的设计模式，
允许对象组合实现与继承相同的代码重用。它的基本作用就是负责任务的调用和分配，
是*一种特殊的静态代理模式*，可以理解为全权代理模式，但是代理模式注重过程，
而*委派模式注重结果*。

委派模式属于行为型设计模式，不属于GoF的23种设计模式。

委派模式适用于以下应用场景。

1. 需要实现表现层和业务层之间的松耦合。
2. 需要编排多个服务之间的调用。
3. 需要封装一层服务查找和调用。

委派模式有3个参与角色。
1. ITask：定义一个抽象接口，它有若干实现类。
2. Concrete：真正执行任务的角色。
3. Delegate：负责在各个具体角色实例之间做出决策，判断并调用具体实现的方法。

优点:
将一个大型任务细化

缺点:
任务委派方式需要根据任务的复杂程度进行不同的改变，在任务比较复杂的情况下，可能需要进行多重委派，容易造成紊乱。

相关内容: JDK双亲委派

# 桥接模式

对于多个变化维度，将各维度抽象出来并各自加以实现，从而将事物本身具有的不同维度的性质以组合/聚合的方式重新
组织起来，降低代码上的耦合。

桥接模式包含如下角色：

- Abstraction：某类事物所共有的方法（比如IMessage#send）
- RefinedAbstraction：这类事物所具有的某个维度的性质，作为一个抽象（比如将消息的紧急程度作为一个抽象）
- Implementor：某类事物的具体实例
- ConcreteImplementor：某类事物在某个维度的性质上的实例

优点：
- 桥接模式提高了系统的可扩充性，在变化维度中任意扩展一个维度，都不需要修改原有系统。
- 符合开闭原则。
- 符合合成复用原则。
- 分离抽象部分及其具体实现部分（事物本身和事物的性质的实现）。

缺点：
- 增加了系统的理解与设计难度。
- 需要正确地识别系统中独立变化的维度。

# 装饰器模式

装饰器模式（Decorator Pattern）也叫作包装器模式（Wrapper Pattern），指在不改变原有对象的基础上，
动态地给一个对象添加一些额外的职责。
就增加功能来说，装饰器模式相比生成子类更为灵活，属于结构型设计模式。

装饰器模式在代码程序中适用于以下应用场景:
- 用于*扩展*一个类的功能，或者给一个类添加附加职责。
- *动态*地给一个对象添加功能，这些功能可以再动态地被撤销。
- 需要为一批平行的兄弟类进行改装或加装功能。

装饰器模式主要包含4个角色:
- Component接口: ConcreteComponent和Decorator都实现Component接口
- ConcreteComponent: 被装饰的原始对象
- Decorator抽象类: 装饰器基类, 也是Component类型
- ConcreteDecorator: 扩展Component对象的一种功能

让装饰器与被装饰类ConcreteComponent实现相同的接口Component，使得装饰器与被扩展类类型一致，
并在构造函数中传入该接口对象，然后在实现这个接口的被包装类对象的现有功能上添加新功能。

由于装饰器与被包装类属于同一类型（均为Component），且构造函数的参数为其实现接口类（Component），
因此装饰器模式具备嵌套扩展功能，这样就能使用装饰器模式一层一层地对底层被包装类进行功能扩展了。

相关内容:
- JDK InputStream等一系列Stream
- 与代理模式的区别: 装饰器模式是以原始类本身为主语进行功能拓展, 而代理模式是以代理类为主语。

# 门面模式

门面模式（Facade Pattern）又叫作外观模式，提供了一个统一的接口，用来访问子系统中的一群接口。
其主要特征是定义了一个高层接口，让子系统更容易使用，属于结构型设计模式。

门面模式主要包含2个角色:
- Facade: 对外的统一接口
- SubSystem: 需要被规范访问的多个子系统

优点:
- 简化调用过程, 减少对子系统的依赖
- 划分访问层次, 提高安全性
- 遵循最少知道原则(迪米特法则)

缺点:
- 当增加子系统和扩展子系统行为时，可能容易带来未知风险。
- 不符合开闭原则(对拓展开放,对修改关闭): 如果新增了服务, 则当前门面接口也要修改
- 某些情况下，可能违背单一职责原则。

# 适配器模式

适配器模式（Adapter Pattern）又叫作变压器模式，它的功能是将一个类的接口变成客户端所期望的另一种接口，
从而使原本因接口不匹配而导致无法在一起工作的两个类能够一起工作，属于结构型设计模式。

在软件开发中，基本上任何问题都可以通过增加一个中间层来解决。适配器模式其实就是一个中间层。

适配器模式适用于以下业务场景:
- 已经存在的类，它的方法和需求不匹配（方法结果相同或相似）的情况。
- 适配器模式不是软件设计阶段考虑的设计模式，是随着软件维护，
由于不同产品、不同厂家造成功能类似而接口不相同情况下的解决方案，有种亡羊补牢的感觉.

适配器模式一般包含3个角色:
- ITarget: 新功能所需的接口
- Adaptee: 存在于系统中的旧的接口
- Adapter: 将Adaptee转化为ITarget的类的实例

优点:
- 复用现有类, 现有类不需改动
- 提高程序拓展性

缺点:
- 增加系统复杂性
- 过多使用适配器会使系统代码变得凌乱

# 组合模式
组合模式（Composite Pattern）又叫作整体-部分（Part-Whole）模式，
它的宗旨是通过将单个对象（叶子节点）和组合对象（树枝节点）用相同的接口进行表示，
使得客户对单个对象和组合对象的使用具有一致性，属于结构型设计模式。

WindowContainer??? 太是了！

在组合模式中，整个树形结构中的对象都属于同一种类型，带来的好处就是用户不需要辨别是树枝节点还是叶子节点，可以直接进行操作，
给用户的使用带来极大的便利。

如果树枝节点和叶子节点具有不同类型，那么需要多个集合维护其它对象层次，比如例如List＜Composite＞，List＜Leaf＞。
这给树枝节点的构建带来了巨大的复杂性、臃肿性及不可扩展性。
同时，当客户端访问该系统层次时，还需进行层次区分，这样才能使用对应的行为，给客户端的使用也带来了巨大的复杂性。

组合模式抽取了系统各个层次的共性行为，具体层次只要按需实现所需行为即可，这样子系统各个层次就都属于同一种类型，
所以树枝节点只需维护一个集合（List＜Component＞）即可存储系统所有层次的内容，
并且客户端也不需要区分该系统各个层次的对象，对内系统架构简洁优雅，对外接口精简易用。

透明组合模式：
透明组合模式是把所有公共方法都定义在Component中，这样做的好处是客户端无须分辨叶子节点和树枝节点，它们具备完全一致的接口。

安全组合模式：
安全组合模式只规定系统各个层次的最基础的一致行为，而把组合（节点）本身的方法（管理子类对象的添加、删除等）放到自身当中。

相关内容：
AOSP WindowContainer树形结构

# 代理模式
在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端与目标对象之间起到中介的作用。

使用代理模式主要有两个目的：一是保护目标对象，二是增强目标对象。

在代码中，一般代理会被理解为代码增强，实际上就是在原代码逻辑前后增加一些代码逻辑，而使调用者无感知。
代理模式分为静态代理和动态代理。

一些例子：

- 比如binder的Stub.asInterface，实际上binder是一个引用地址（有点不确定），然后在本地通过Proxy类封装了通过binder
进行的RPC调用，Parcel，在binder外包裹了一层操作。binder只是binder，通信过程由Proxy描述。

- 图片代理：一个很常见的代理模式的应用实例就是对大图浏览的控制。

    用户通过浏览器访问网页时先不加载真实的大图，而是通过代理对象的方法来进行处理，在代理对象的方法中，先使用一个线程向客户端
浏览器加载一个小图片， 然后在后台使用另一个线程来调用大图片的加载方法将大图片加载到客户端。当需要浏览大图片时，再将大图片在新
网页中显示。如果用户在浏览大图时加载工作还没有完成，可以再启动一个线程来显示相应的提示信息。通过代理技术结合多线程编程将真实
图片的加载放到后台来操作，不影响前台图片的浏览。

- 远程代理：远程代理可以将网络的细节隐藏起来，使得客户端不必考虑网络的存在。如，binder。

    客户完全可以认为被代理的远程业务对象是局域的而不是远程的，而远程代理对象承担了大部分的网络通信工作。

- 虚拟代理：当一个对象的加载十分耗费资源的时候，虚拟代理的优势就非常明显地体现出来了。

  虚拟代理模式是一种内存节省技术，那些占用大量内存或处理复杂的对象将推迟到使用它的时候才创建。

动态代理

动态代理是一种较为高级的代理模式，它的典型应用就是Spring AOP。
在传统的代理模式中，客户端通过Proxy调用RealSubject类的request()方法，
同时还在代理类中封装了其他方法(如preRequest()和postRequest())，可以处理一些其他问题。
如果按照这种方法使用代理模式，那么真实主题角色必须是**事先已经存在**的，并将其作为代理对象的内部成员属性。

如果一个真实主题角色必须对应一个代理主题角色，这将导致系统中的类个数急剧增加，因此需要想办法减少系统中类的个数，
此外，如何在事先不知道真实主题角色的情况下使用代理主题角色，这都是动态代理需要解决的问题。

JDK中自带的动态代理采用字节码重组的方式，重新生成对象来替代原始对象。

JDK动态代理生成对象的步骤如下。

（1）获取被代理对象的引用，并且获取它的所有接口，反射获取。

（2）JDK动态代理类重新生成一个新的类，同时新的类要实现被代理类实现的所有接口。

（3）动态生成Java代码，新加的业务逻辑方法由一定的逻辑代码调用（在代码中体现）。

（4）编译新生成的Java代码.class文件。

（5）重新加载到JVM中运行。

以上过程就叫作字节码重组。JDK中有一个规范，在ClassPath下只要是$开头的.class文件，一般都是自动生成的。

相关内容：
- JDK动态代理
- CGLib动态代理

# 享元模式
当对象数量太多时，将导致运行代价过高，带来性能下降等问题。享元模式正是为解决这一类问题而诞生的。
享元模式（Flyweight Pattern）又叫作轻量级模式，是对象池的一种实现。
其宗旨是共享细粒度对象，将多个对同一对象的访问集中起来，不必为每个访问者都创建一个单独的对象，
以此来降低内存的消耗，属于结构型设计模式。

享元模式把一个对象的状态分成内部状态和外部状态，内部状态是不变的，外部状态是变化的；然后通过共享
不变的部分，达到减少对象数量并节约内存的目的。享元模式的本质是缓存共享对象，降低内存消耗。

享元模式其实是工厂方法模式的一个改进机制，享元模式同样要求创建一个或一组对象，并且就是通过工厂方
法模式生成对象的，只不过享元模式为工厂方法模式增加了缓存这一功能。

优点:
- 减少对象的创建
- 减少资源占用

缺点:
- 线程安全问题
- 区分内外部状态, 内部需要为通用状态

# 建造者模式

- 构建与表示分离：使用接口规定行为，然后由具体的实现类进行构建（抽象工厂接口+具体工厂实现）。
- 创建不同的表示：也就是具备同样的行为，但是却由于构建的行为顺序不同或其他原因可以创建出
不同的表示。

从定义来看，建造者模式和工厂模式是非常相似的，和工厂模式一样，具备创建与表示分离的特性。
建造者模式唯一区别于工厂模式的是针对复杂对象的创建。
也就是说，如果创建简单对象，通常都是使用工厂模式进行创建；而如果创建复杂对象，
就可以考虑使用建造者模式。

优点：
- 封装性好，构建和表示分离
- 拓展性好，建造类独立
- 便于控制细节

缺点：
- 需要一个IBuilder接口定义
- 如果产品发生变化，则Builder也要修改

适用情况：
- 相同的方法，不同的执行顺序，产生不同的结果。
- 多个部件或零件，都可以装配到一个对象中，但是产生的结果又不相同。
- 产品类非常复杂，或者产品类中不同的调用顺序产生不同的作用。
- 初始化一个对象特别复杂，参数多，而且很多参数都具有默认值。

工厂模式只需要把对象创建出来就可以了，而建造者模式不仅要创建出对象，还要知道对象由哪些部件组成。

# 简单工厂模式

简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，
而无须知道其创建细节。

优点：
- 隐藏创建细节

缺点：
- 工厂类不够灵活，拓展时需要修改原有代码
- 产品较多时，工厂类代码臃肿

适用情况：
- 工厂类负责创建的对象比较少；
- 客户端只知道传入工厂类的参数，对于如何创建对象不关心。

# 工厂方法模式

由具体工厂类来决定初始化哪一个具体产品。
某具体产品由专门的具体工厂创建，它们之间往往一一对应。
- 抽象工厂接口
- 具体工厂
- 抽象产品接口
- 具体产品

优点：
- 隐藏创建细节
- 便于拓展
- 解耦框架。高层模块只需要知道产品的抽象类，无须关心其他实现类，满足迪米特法则、依赖倒置原则和里氏替换原则。

缺点：
- 需要创建更多的类，增加系统复杂性
- 抽象产品只能生产一种产品，此弊端可使用抽象工厂模式解决

适用情况：
- 客户端只知道传入工厂类的参数，对于如何创建对象不关心
- 需要对产品类进行拓展的情况

# 原型模式

不是通过new关键字而是通过对象复制来实现创建对象的模式被称作原型模式。Java中提供了Cloneable接口作为抽象原型接口。

原型模式的核心在于复制原型对象。以系统中已存在的一个对象为原型，直接基于内存二进制流进行复制，不需要再经历耗时的对象初始化过程（不调用构造函数），性能提升许多。

Java提供Cloneable接口，为了在运行时通知Java虚拟机可以安全地在该类上使用clone()方法。而如果该类没有实现 Cloneable接口，则调用clone()方法会抛出 CloneNotSupportedException异常。一般情况下，如果使用clone()方法，则需满足以下条件。
- 对任何对象o，都有o.clone() != o。换言之，克隆对象与原型对象不是同一个对象。
- 对任何对象o，都有o.clone().getClass() == o.getClass()。换言之，克隆对象与原型对象的类型一样。
- 如果对象o的equals()方法定义恰当，则o.clone().equals(o)应当成立。

clone()的方式是浅拷贝。为了使用深拷贝通常使用序列化的方式。

优点：
- 基于二进制流的对象复制比new更快
- 可以保存对象状态

缺点：
- 每个类都要配置一个clone方法
- clone方法位于类的内部，当对已有类进行改造的时候，需要修改代码，违背了开闭原则
- 当实现深克隆时，需要编写较为复杂的代码，而且当对象之间存在多重嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来会比较麻烦

适用情况：
- 创建对象成本较大（例如，初始化时间长，占用CPU太多，或者占用网络资源太多等），需要优化资源
- 创建一个对象需要烦琐的数据准备或访问权限等，需要提高性能或者提高安全性
- 系统中大量使用该类对象，且各个调用者都需要给它的属性重新赋值


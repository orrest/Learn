# 原则

1. 开闭原则：对拓展开放，对修改关闭
2. 依赖倒置：依赖抽象，降低耦合
3. 单一职责：单一职责、降低耦合
4. 接口隔离：不要使用单一的总接口
5. 迪米特法则：最少知道原则
6. 里氏替换原则：子类父类可以替换，使用方法不变
7. 合成复用原则：使用组合、聚合，避免继承

# 简单工厂模式

简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。

优点：
- 隐藏创建细节

缺点：
- 工厂类不够灵活，拓展时需要修改原有代码
- 产品较多时，工厂类代码臃肿

适用情况：
- 工厂类负责创建的对象比较少；
- 客户端只知道传入工厂类的参数，对于如何创建对象不关心。

# 工厂方法模式

由具体工厂类来决定初始化哪一个具体产品。
某具体产品由专门的具体工厂创建，它们之间往往一一对应。
- 抽象工厂接口
- 具体工厂
- 抽象产品接口
- 具体产品

优点：
- 隐藏创建细节
- 便于拓展
- 解耦框架。高层模块只需要知道产品的抽象类，无须关心其他实现类，满足迪米特法则、依赖倒置原则和里氏替换原则。

缺点：
- 需要创建更多的类，增加系统复杂性
- 抽象产品只能生产一种产品，此弊端可使用抽象工厂模式解决

适用情况：
- 客户端只知道传入工厂类的参数，对于如何创建对象不关心
- 需要对产品类进行拓展的情况

# 原型模式

不是通过new关键字而是通过对象复制来实现创建对象的模式被称作原型模式。Java中提供了Cloneable接口作为抽象原型接口。

原型模式的核心在于复制原型对象。以系统中已存在的一个对象为原型，直接基于内存二进制流进行复制，不需要再经历耗时的对象初始化过程（不调用构造函数），性能提升许多。

Java提供Cloneable接口，为了在运行时通知Java虚拟机可以安全地在该类上使用clone()方法。而如果该类没有实现 Cloneable接口，则调用clone()方法会抛出 CloneNotSupportedException异常。一般情况下，如果使用clone()方法，则需满足以下条件。
- 对任何对象o，都有o.clone() != o。换言之，克隆对象与原型对象不是同一个对象。
- 对任何对象o，都有o.clone().getClass() == o.getClass()。换言之，克隆对象与原型对象的类型一样。
- 如果对象o的equals()方法定义恰当，则o.clone().equals(o)应当成立。

clone()的方式是浅拷贝。为了使用深拷贝通常使用序列化的方式。

优点：
- 基于二进制流的对象复制比new更快
- 可以保存对象状态

缺点：
- 每个类都要配置一个clone方法
- clone方法位于类的内部，当对已有类进行改造的时候，需要修改代码，违背了开闭原则
- 当实现深克隆时，需要编写较为复杂的代码，而且当对象之间存在多重嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来会比较麻烦

适用情况：
- 创建对象成本较大（例如，初始化时间长，占用CPU太多，或者占用网络资源太多等），需要优化资源
- 创建一个对象需要烦琐的数据准备或访问权限等，需要提高性能或者提高安全性
- 系统中大量使用该类对象，且各个调用者都需要给它的属性重新赋值


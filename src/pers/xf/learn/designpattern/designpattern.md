# 原则

1. 开闭原则：对拓展开放，对修改关闭
2. 依赖倒置：依赖抽象，降低耦合
3. 单一职责：单一职责、降低耦合
4. 接口隔离：不要使用单一的总接口
5. 迪米特法则：最少知道原则
6. 里氏替换原则：子类父类可以替换，使用方法不变
7. 合成复用原则：使用组合、聚合，避免继承

# 访问者模式

在访问者模式（Visitor Pattern）中，
我们使用了一个访问者类，它改变了元素类的执行算法。
通过这种方式，元素的执行算法可以随着访问者改变而改变。
这种类型的设计模式属于行为型模式。根据模式，元素对象已接受访问者对象，
这样访问者对象就可以处理元素对象上的操作。

collection.accept(new ConcreteVisitorA()) -> for ele in elements: ele.accept(visitor) 
-> ele::visitor.visit(ele)

首先通过visitor来区分角色, 同时在visitor中也定义了不同角色的功能实现;

然后context接受这样一个访问者对象, 并将其传给所有的元素, 这些元素再通过这个访问者对象调用访问者的具体visit方法.

使用场景：
 - 对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作。 
 - 需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作"污染"这些对象的类，
 也不希望在增加新操作时修改这些类。
 
 访问者模式主要包含5个角色:
 - IVisitor: 接口或抽象类，该类定义了一个visit（）方法用于访问每一个具体的元素，其参数就是具体的元素对象。
 从理论上来说，IVisitor的方法个数与元素个数是相等的。
 如果元素个数经常变动，则导致IVisitor的方法也要进行变动，此时，该情形并不适用于访问者模式
 - ConcreteVisitor: 实现对具体元素的操作
 - IElement: 接口或抽象类，定义了一个接受访问者访问的方法accept（），表示所有元素类型都支持被访问者访问
 - ConcreteElement: 具体元素类型，提供接受访问者的具体实现。通常的实现都为visitor.visit（this）
 - ObjectStructure: ：该类内部维护了元素集合，并提供方法接受访问者对该集合所有元素进行操作
 
 优点:
 - 解耦数据结构和数据操作
 - 拓展性
 
 缺点:
 - 难以增加元素类型
 - 难以修改元素类型
 - 违背依赖倒置原则

# 观察者模式

观察者模式（Observer Pattern）又叫作发布-订阅（Publish/Subscribe）模式、
模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或
从属者（Dependent）模式。
定义一种一对多的依赖关系，一个主题对象可被多个观察者对象同时监听，
使得每当主题对象状态变化时，所有依赖它的对象都会得到通知并被自动更新，属于行为型设计模式。

观察者模式的核心是将观察者与被观察者解耦，以类似消息/广播发送的机制联动两者，
使被观察者的变动能通知到感兴趣的观察者们，从而做出相应的响应。

观察者模式主要适用于以下应用场景
- 当一个抽象模型包含两方面内容，其中一方面依赖另一方面
- 其他一个或多个对象的变化依赖另一个对象的变化
- 实现类似广播机制的功能，不需要知道具体收听者，只需分发广播，系统中感兴趣的对象会自动接收该广播
- 多层级嵌套使用，形成一种链式触发机制，使得事件具备跨域（跨越两种观察者类型）通知

观察者模式主要包含4个角色
- IEvent: 抽象类或接口，定义了增加、删除、通知方法
- EventContext: 内部状态变化时，会通知已注册的观察者
- IListener: 定义了响应通知更新的方法
- ListenerImpl: 实现更新后做出响应

在EventContext中, 通过addListener方法解析eventType, 然后
根据解析出的eventType反射获取到Listener中的onXxx方法, 
作为callback创建给Event对象put到事件队列中。

当事件发生的时候, trigger这个事件(从事件队列中获取）.

优点:
- 松耦合, 符合依赖倒置.
- 分离了表示层和数据逻辑层, 并且建立了一套触发机制，使得数据的变化可以响应到多个表示层上

缺点:
- 如果观察者数量过多，则事件通知会耗时较长
- 事件通知呈线性关系，如果其中一个观察者处理事件卡壳，则会影响后续的观察者接收该事件(这个应该可以规避)
- 如果观察者和被观察者之间存在循环依赖，则可能造成两者之间的循环调用，导致系统崩溃

相关内容:
- Handler? onTouchEventListener?

# 解释器模式

解释器模式（Interpreter Pattern）指给定一门语言，定义它的文法的一种表示，
并定义一个解释器，该解释器使用该表示来解释语言中的句子。
解释器模式是一种按照规定的文法（语法）进行解析的模式，属于行为型设计模式。

解释器模式主要适用于以下应用场景:
- 一些重复出现的问题可以用一种简单的语言进行表达
- 一个简单语法需要解释的场景

解释器模式主要包含4个角色:
- IInterpreter: 负责定义一个解释方法interpret，交由具体子类进行具体解释
- TerminalInterpreter: 实现文法中与终结符有关的解释操作。
文法中的每一个终结符都有一个具体终结表达式与之相对应，
比如公式R=R1+R2，R1和R2就是终结符，对应的解析R1和R2的解释器就是终结符表达式。
通常一个解释器模式中只有一个终结符表达式，但有多个实例，对应不同的终结符(如R1、R2)
- NonterminalInterpreter: 实现文法中与非终结符有关的解释操作。
文法中的每条规则都对应一个非终结符表达式。
非终结符表达式一般是文法中的运算符或者其他关键字，
比如在公式R=R1+R2中，“+”就是非终结符，解析“+”的解释器就是一个非终结符表达式。
非终结符表达式根据逻辑的复杂程度而增加，原则上每个文法规则都对应一个非终结符表达式。
- Context: 包含解释器之外的全局信息。
它一般用来存放文法中各个终结符所对应的具体值，
比如R=R1+R2，给R1赋值100，给R2赋值200，这些信息需要被存放到环境中。

优点:
- 可拓展性: 在解释器模式中，由于语法是由很多类表示的，当语法规则更改时，
只需修改相应的非终结符表达式即可；当扩展语法时，只需添加相应的非终结符类即可。

缺点:
- 解释器模式的每个语法都要产生一个非终结符表达式，
当语法规则比较复杂时，就会产生大量解释类，引起类膨胀，增加系统维护的难度。
- 解释器模式采用递归调用方法，每个非终结符表达式都只关心与自己有关的表达式，
每个表达式都需要知道最终的结果，因此完整表达式的最终结果是通过从后往前递归调用的方式获取的。
当完整表达式层级较深时，解释效率下降，且出错时调试困难，因为递归迭代的层级太深。

相关内容:
- regex

# 中介者模式

中介者模式（Mediator Pattern）又叫作调解者模式或调停者模式。
用一个中介对象封装一系列对象交互，中介者使各对象不需要显式地相互作用，
从而使其耦合松散，而且可以独立地改变它们之间的交互，属于行为型设计模式。

中介者模式是用来降低多个对象和类之间的通信复杂性的。
这种模式通过提供一个中介类，将系统各层次对象间的多对多关系变成一对多关系，
中介者对象可以将复杂的网状结构变成以中介者为中心的星形结构，达到降低系统的复杂性、提高可扩展性的作用。

中介者模式主要适用于以下应用场景:
- 复杂引用关系
- 复杂交互行为

包含4个角色:
- IMediator: 中间人接口, 定义通信标准
- ConcreteMediator: 中间人实现, 实现接口, 汇总协调各
- ICharacter: 抽象角色, 持有一个中间人引用
- Character: 具体角色, 实现ICharacter, 通过Mediator通信

优点:
- 简化类间依赖, 多对多转化为一对多
- 符合迪米特法则

缺点:
- 中介者可能会变得很臃肿

# 备忘录模式

备忘录模式（Memento Pattern）又叫作*快照模式*（Snapshot Pattern）或令牌模式（Token Pattern），
指在不破坏封装的前提下，捕获一个对象的内部状态，并在对象之外保存这个状态。
这样以后就可将该对象恢复到原先保存的状态，属于行为型设计模式。

备忘录模式主要适用于以下应用场景:
- 需要保存历史快照的场景
- 希望在对象之外保存状态，且除了自己，其他类对象无法访问状态保存的具体内容

三个角色:
- Originator: 需要被保存的对象
- Memento: 用于存储Originator的内部状态的对象
- Caretaker: 负责存储, 管理快照

优点:
- 简化被保存对象的职责, 客户端无需关心保存细节
- 提供状态回滚功能

缺点:
- 消耗内存

# 状态模式

允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类，属于行为型设计模式。
其意图是让一个对象在其内部改变的时候，行为也随之改变。状态模式的核心是状态与行为绑定，不同的状态对应不同的行为。

状态模式主要解决的就是控制一个对象状态的条件表达式过于复杂时的情况。

状态模式主要适用于以下应用场景:
- 行为随状态改变而改变的场景
- 一个操作中含有庞大的多分支结构，并且这些分支取决于对象的状态

状态模式主要包含3个角色:
- Context: 维护实例的状态, 负责状态的切换
- AbstractState: 抽象状态类
- ConcreteState: 具体状态

优点:
- 结构清晰, 减少逻辑判断语句
- 将状态转换显示化
- 状态类职责明确具备拓展性

缺点:
- 类膨胀
- 结构与实现复杂
- 不支持开闭原则, 增加新的状态需要修改原来代码

相关内容:
- Android框架中Activity的生命周期的变化?

# 命令模式

命令模式（Command Pattern）是对命令的封装，每一个命令都是一个操作：
请求方发出请求要求执行一个操作；接收方收到请求，并执行操作。
命令模式解耦了请求方和接收方，请求方只需请求执行命令，不用关心命令怎样被接收、怎样被操作及是否被执行等。
命令模式属于行为型设计模式。

在软件系统中，行为请求者与行为实现者通常是一种紧耦合关系，因为这样的实现简单明了。
但紧耦合关系缺乏扩展性，在某些场合中，当需要对行为进行记录、撤销或重做等处理时，只能修改源码。
而命令模式通过在请求与实现间引入一个抽象命令接口，解耦了请求与实现，并且中间件是抽象的，它由不同的子类实现，因此具备扩展性。
所以，命令模式的本质是解耦命令请求与处理。

命令模式主要适用于以下应用场景：
- 现实语义中具备“命令”的操作（如命令菜单、Shell命令等）
- 请求的调用者和接收者需要解耦，使得调用者和接收者不直接交互
- 需要抽象出等待执行的行为，比如撤销（Undo）操作和恢复（Redo）等操作
- 需要支持命令宏（即命令组合操作）。

命令模式主要包含4个角色:
- Receiver：实际执行请求, 如GPlayer
- ICommand：定义执行命令的接口
- ConcreteCommand：该类内部维护一个Receiver，在其execute()方法中调用Receiver的相关方法.
如, PlayAction.
- Invoker：接收客户端的命令, 通过相应ICommand实现类执行命令

优点:
- 解耦命令与实现。如，命令，PlayAction；实现，GPlayer.play()
- 拓展性良好（？存疑，如果加入Receiver没有的新命令)
- 支持命令组合、支持命令队列

缺点:
- 命令类变多，引入额外类型结构

# 迭代器模式

迭代器模式（Iterator Pattern）又叫作游标模式（Cursor Pattern），
它提供一种按顺序访问集合/容器对象元素的方法，而又无须暴露集合内部表示。
迭代器模式可以为不同的容器提供一致的遍历行为，而不用关心容器内元素的组成结构，属于行为型设计模式。

迭代器模式的本质是把集合对象的迭代行为抽离到迭代器中，解耦元素迭代和集合对象，提供一致的访问接口。

迭代器模式适用于以下应用场景。
- 访问一个集合对象的内容而无须暴露它的内部表示。
- 为遍历不同的集合结构提供一个统一的访问接口。

迭代器模式主要包含4个角色:
- Iterator: 抽象迭代器, 定义迭代器的方法
- ConcreteIterator: 具体迭代器, 提供元素遍历行为
- ICollection: 集合容器接口
- ConcreteCollection: 具体集合容器

优点：
- 多态迭代，统一的遍历接口
- 简化集合对象接口，将迭代行为从集合中分离出来
- 元素迭代功能多样化，可以自定义迭代行为
- 解耦迭代与集合

缺点：
- 对于比较简单的遍历（如数组或者有序列表），使用迭代器模式遍历较为烦琐

相关内容：
- ArrayList

# 策略模式

策略模式使用的就是面向对象的继承和多态机制，从而实现同一行为在不同的场景下具备不同的实现。

策略模式适用于以下应用场景:
- 针对同一类型问题，有多种处理方式，每一种都能独立解决问题。
- 需要自由切换算法的场景。
- 需要屏蔽算法规则的场景。

策略模式主要包含3个角色
- IStrategy：规定策略或算法的行为。
- Context：用来操作策略的上下文环境，屏蔽高层模块（客户端）对策略、算法的直接访问，
封装可能存在的变化。比如PayStrategy，通过Map封装具体策略映射，这样应用时只需给出指令即可。
- ConcreteStrategy：具体的策略或算法实现。

优点：
- 符合开闭原则
- 避免if...else, switch...case（通过Map）
- 提高安全性

缺点：
- 客户端必须知道所有的策略，并且自行决定使用哪一个策略类。
- 代码中会产生非常多策略类，增加维护难度。

# 模板方法模式

模板方法模式（Template Method Pattern）又叫作模板模式，指定义一个操作中的算法的框架，
而将一些步骤延迟到子类中，*使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤*，
属于行为型设计模式。

模板方法模式实际上封装了一个固定流程，该流程由几个步骤组成，具体步骤可以由子类进行不同的实现，
从而让固定的流程产生不同的结果。它非常简单，其实就是类的继承机制，但它却是一个应用非常广泛的模式。
模板方法模式的本质是抽象封装流程，具体进行实现。

模板方法模式适用于以下应用场景:
- 一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现。
- 各子类中公共的行为被提取出来，集中到一个公共的父类中，从而避免代码重复。

优点:
- 提高代码的复用性。
- 提高代码的可扩展性。
- 把不变的行为写在父类上，去除子类的重复代码，提供了一个很好的代码复用平台，符合开闭原则。

缺点:
- 每一个抽象类都需要一个子类来实现，这样导致类数量增加。
- 由于继承关系自身的缺点，如果父类添加新的抽象方法，则所有子类都要改一遍。

相关内容
- JDK AbstractList
- (注解和模板方法模式有关系吗?)

# 委派模式

委派模式（Delegate Pattern）又叫作委托模式，是一种面向对象的设计模式，
允许对象组合实现与继承相同的代码重用。它的基本作用就是负责任务的调用和分配，
是*一种特殊的静态代理模式*，可以理解为全权代理模式，但是代理模式注重过程，
而*委派模式注重结果*。

委派模式属于行为型设计模式，不属于GoF的23种设计模式。

委派模式适用于以下应用场景。

1. 需要实现表现层和业务层之间的松耦合。
2. 需要编排多个服务之间的调用。
3. 需要封装一层服务查找和调用。

委派模式有3个参与角色。
1. ITask：定义一个抽象接口，它有若干实现类。
2. Concrete：真正执行任务的角色。
3. Delegate：负责在各个具体角色实例之间做出决策，判断并调用具体实现的方法。

优点:
将一个大型任务细化

缺点:
任务委派方式需要根据任务的复杂程度进行不同的改变，在任务比较复杂的情况下，可能需要进行多重委派，容易造成紊乱。

相关内容: JDK双亲委派

# 桥接模式

对于多个变化维度，将各维度抽象出来并各自加以实现，从而将事物本身具有的不同维度的性质以组合/聚合的方式重新
组织起来，降低代码上的耦合。

桥接模式包含如下角色：

- Abstraction：某类事物所共有的方法（比如IMessage#send）
- RefinedAbstraction：这类事物所具有的某个维度的性质，作为一个抽象（比如将消息的紧急程度作为一个抽象）
- Implementor：某类事物的具体实例
- ConcreteImplementor：某类事物在某个维度的性质上的实例

优点：
- 桥接模式提高了系统的可扩充性，在变化维度中任意扩展一个维度，都不需要修改原有系统。
- 符合开闭原则。
- 符合合成复用原则。
- 分离抽象部分及其具体实现部分（事物本身和事物的性质的实现）。

缺点：
- 增加了系统的理解与设计难度。
- 需要正确地识别系统中独立变化的维度。

# 装饰器模式

装饰器模式（Decorator Pattern）也叫作包装器模式（Wrapper Pattern），指在不改变原有对象的基础上，
动态地给一个对象添加一些额外的职责。
就增加功能来说，装饰器模式相比生成子类更为灵活，属于结构型设计模式。

装饰器模式在代码程序中适用于以下应用场景:
- 用于*扩展*一个类的功能，或者给一个类添加附加职责。
- *动态*地给一个对象添加功能，这些功能可以再动态地被撤销。
- 需要为一批平行的兄弟类进行改装或加装功能。

装饰器模式主要包含4个角色:
- Component接口: ConcreteComponent和Decorator都实现Component接口
- ConcreteComponent: 被装饰的原始对象
- Decorator抽象类: 装饰器基类, 也是Component类型
- ConcreteDecorator: 扩展Component对象的一种功能

让装饰器与被装饰类ConcreteComponent实现相同的接口Component，使得装饰器与被扩展类类型一致，
并在构造函数中传入该接口对象，然后在实现这个接口的被包装类对象的现有功能上添加新功能。

由于装饰器与被包装类属于同一类型（均为Component），且构造函数的参数为其实现接口类（Component），
因此装饰器模式具备嵌套扩展功能，这样就能使用装饰器模式一层一层地对底层被包装类进行功能扩展了。

相关内容:
- JDK InputStream等一系列Stream
- 与代理模式的区别: 装饰器模式是以原始类本身为主语进行功能拓展, 而代理模式是以代理类为主语。

# 门面模式

门面模式（Facade Pattern）又叫作外观模式，提供了一个统一的接口，用来访问子系统中的一群接口。
其主要特征是定义了一个高层接口，让子系统更容易使用，属于结构型设计模式。

门面模式主要包含2个角色:
- Facade: 对外的统一接口
- SubSystem: 需要被规范访问的多个子系统

优点:
- 简化调用过程, 减少对子系统的依赖
- 划分访问层次, 提高安全性
- 遵循最少知道原则(迪米特法则)

缺点:
- 当增加子系统和扩展子系统行为时，可能容易带来未知风险。
- 不符合开闭原则(对拓展开放,对修改关闭): 如果新增了服务, 则当前门面接口也要修改
- 某些情况下，可能违背单一职责原则。

# 适配器模式

适配器模式（Adapter Pattern）又叫作变压器模式，它的功能是将一个类的接口变成客户端所期望的另一种接口，
从而使原本因接口不匹配而导致无法在一起工作的两个类能够一起工作，属于结构型设计模式。

在软件开发中，基本上任何问题都可以通过增加一个中间层来解决。适配器模式其实就是一个中间层。

适配器模式适用于以下业务场景:
- 已经存在的类，它的方法和需求不匹配（方法结果相同或相似）的情况。
- 适配器模式不是软件设计阶段考虑的设计模式，是随着软件维护，
由于不同产品、不同厂家造成功能类似而接口不相同情况下的解决方案，有种亡羊补牢的感觉.

适配器模式一般包含3个角色:
- ITarget: 新功能所需的接口
- Adaptee: 存在于系统中的旧的接口
- Adapter: 将Adaptee转化为ITarget的类的实例

优点:
- 复用现有类, 现有类不需改动
- 提高程序拓展性

缺点:
- 增加系统复杂性
- 过多使用适配器会使系统代码变得凌乱

# 组合模式
组合模式（Composite Pattern）又叫作整体-部分（Part-Whole）模式，
它的宗旨是通过将单个对象（叶子节点）和组合对象（树枝节点）用相同的接口进行表示，
使得客户对单个对象和组合对象的使用具有一致性，属于结构型设计模式。

WindowContainer??? 太是了！

在组合模式中，整个树形结构中的对象都属于同一种类型，带来的好处就是用户不需要辨别是树枝节点还是叶子节点，可以直接进行操作，
给用户的使用带来极大的便利。

如果树枝节点和叶子节点具有不同类型，那么需要多个集合维护其它对象层次，比如例如List＜Composite＞，List＜Leaf＞。
这给树枝节点的构建带来了巨大的复杂性、臃肿性及不可扩展性。
同时，当客户端访问该系统层次时，还需进行层次区分，这样才能使用对应的行为，给客户端的使用也带来了巨大的复杂性。

组合模式抽取了系统各个层次的共性行为，具体层次只要按需实现所需行为即可，这样子系统各个层次就都属于同一种类型，
所以树枝节点只需维护一个集合（List＜Component＞）即可存储系统所有层次的内容，
并且客户端也不需要区分该系统各个层次的对象，对内系统架构简洁优雅，对外接口精简易用。

透明组合模式：
透明组合模式是把所有公共方法都定义在Component中，这样做的好处是客户端无须分辨叶子节点和树枝节点，它们具备完全一致的接口。

安全组合模式：
安全组合模式只规定系统各个层次的最基础的一致行为，而把组合（节点）本身的方法（管理子类对象的添加、删除等）放到自身当中。

相关内容：
AOSP WindowContainer树形结构

# 代理模式
在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端与目标对象之间起到中介的作用。

使用代理模式主要有两个目的：一是保护目标对象，二是增强目标对象。

在代码中，一般代理会被理解为代码增强，实际上就是在原代码逻辑前后增加一些代码逻辑，而使调用者无感知。
代理模式分为静态代理和动态代理。

一些例子：

- 比如binder的Stub.asInterface，实际上binder是一个引用地址（有点不确定），然后在本地通过Proxy类封装了通过binder
进行的RPC调用，Parcel，在binder外包裹了一层操作。binder只是binder，通信过程由Proxy描述。

- 图片代理：一个很常见的代理模式的应用实例就是对大图浏览的控制。

    用户通过浏览器访问网页时先不加载真实的大图，而是通过代理对象的方法来进行处理，在代理对象的方法中，先使用一个线程向客户端
浏览器加载一个小图片， 然后在后台使用另一个线程来调用大图片的加载方法将大图片加载到客户端。当需要浏览大图片时，再将大图片在新
网页中显示。如果用户在浏览大图时加载工作还没有完成，可以再启动一个线程来显示相应的提示信息。通过代理技术结合多线程编程将真实
图片的加载放到后台来操作，不影响前台图片的浏览。

- 远程代理：远程代理可以将网络的细节隐藏起来，使得客户端不必考虑网络的存在。如，binder。

    客户完全可以认为被代理的远程业务对象是局域的而不是远程的，而远程代理对象承担了大部分的网络通信工作。

- 虚拟代理：当一个对象的加载十分耗费资源的时候，虚拟代理的优势就非常明显地体现出来了。

  虚拟代理模式是一种内存节省技术，那些占用大量内存或处理复杂的对象将推迟到使用它的时候才创建。

动态代理

动态代理是一种较为高级的代理模式，它的典型应用就是Spring AOP。
在传统的代理模式中，客户端通过Proxy调用RealSubject类的request()方法，
同时还在代理类中封装了其他方法(如preRequest()和postRequest())，可以处理一些其他问题。
如果按照这种方法使用代理模式，那么真实主题角色必须是**事先已经存在**的，并将其作为代理对象的内部成员属性。

如果一个真实主题角色必须对应一个代理主题角色，这将导致系统中的类个数急剧增加，因此需要想办法减少系统中类的个数，
此外，如何在事先不知道真实主题角色的情况下使用代理主题角色，这都是动态代理需要解决的问题。

JDK中自带的动态代理采用字节码重组的方式，重新生成对象来替代原始对象。

JDK动态代理生成对象的步骤如下。

（1）获取被代理对象的引用，并且获取它的所有接口，反射获取。

（2）JDK动态代理类重新生成一个新的类，同时新的类要实现被代理类实现的所有接口。

（3）动态生成Java代码，新加的业务逻辑方法由一定的逻辑代码调用（在代码中体现）。

（4）编译新生成的Java代码.class文件。

（5）重新加载到JVM中运行。

以上过程就叫作字节码重组。JDK中有一个规范，在ClassPath下只要是$开头的.class文件，一般都是自动生成的。

相关内容：
- JDK动态代理
- CGLib动态代理

# 享元模式
当对象数量太多时，将导致运行代价过高，带来性能下降等问题。享元模式正是为解决这一类问题而诞生的。
享元模式（Flyweight Pattern）又叫作轻量级模式，是对象池的一种实现。
其宗旨是共享细粒度对象，将多个对同一对象的访问集中起来，不必为每个访问者都创建一个单独的对象，
以此来降低内存的消耗，属于结构型设计模式。

享元模式把一个对象的状态分成内部状态和外部状态，内部状态是不变的，外部状态是变化的；然后通过共享
不变的部分，达到减少对象数量并节约内存的目的。享元模式的本质是缓存共享对象，降低内存消耗。

享元模式其实是工厂方法模式的一个改进机制，享元模式同样要求创建一个或一组对象，并且就是通过工厂方
法模式生成对象的，只不过享元模式为工厂方法模式增加了缓存这一功能。

优点:
- 减少对象的创建
- 减少资源占用

缺点:
- 线程安全问题
- 区分内外部状态, 内部需要为通用状态

# 建造者模式

- 构建与表示分离：使用接口规定行为，然后由具体的实现类进行构建（抽象工厂接口+具体工厂实现）。
- 创建不同的表示：也就是具备同样的行为，但是却由于构建的行为顺序不同或其他原因可以创建出
不同的表示。

从定义来看，建造者模式和工厂模式是非常相似的，和工厂模式一样，具备创建与表示分离的特性。
建造者模式唯一区别于工厂模式的是针对复杂对象的创建。
也就是说，如果创建简单对象，通常都是使用工厂模式进行创建；而如果创建复杂对象，
就可以考虑使用建造者模式。

优点：
- 封装性好，构建和表示分离
- 拓展性好，建造类独立
- 便于控制细节

缺点：
- 需要一个IBuilder接口定义
- 如果产品发生变化，则Builder也要修改

适用情况：
- 相同的方法，不同的执行顺序，产生不同的结果。
- 多个部件或零件，都可以装配到一个对象中，但是产生的结果又不相同。
- 产品类非常复杂，或者产品类中不同的调用顺序产生不同的作用。
- 初始化一个对象特别复杂，参数多，而且很多参数都具有默认值。

工厂模式只需要把对象创建出来就可以了，而建造者模式不仅要创建出对象，还要知道对象由哪些部件组成。

# 简单工厂模式

简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，
而无须知道其创建细节。

优点：
- 隐藏创建细节

缺点：
- 工厂类不够灵活，拓展时需要修改原有代码
- 产品较多时，工厂类代码臃肿

适用情况：
- 工厂类负责创建的对象比较少；
- 客户端只知道传入工厂类的参数，对于如何创建对象不关心。

# 工厂方法模式

由具体工厂类来决定初始化哪一个具体产品。
某具体产品由专门的具体工厂创建，它们之间往往一一对应。
- 抽象工厂接口
- 具体工厂
- 抽象产品接口
- 具体产品

优点：
- 隐藏创建细节
- 便于拓展
- 解耦框架。高层模块只需要知道产品的抽象类，无须关心其他实现类，满足迪米特法则、依赖倒置原则和里氏替换原则。

缺点：
- 需要创建更多的类，增加系统复杂性
- 抽象产品只能生产一种产品，此弊端可使用抽象工厂模式解决

适用情况：
- 客户端只知道传入工厂类的参数，对于如何创建对象不关心
- 需要对产品类进行拓展的情况

# 原型模式

不是通过new关键字而是通过对象复制来实现创建对象的模式被称作原型模式。Java中提供了Cloneable接口作为抽象原型接口。

原型模式的核心在于复制原型对象。以系统中已存在的一个对象为原型，直接基于内存二进制流进行复制，不需要再经历耗时的对象初始化过程（不调用构造函数），性能提升许多。

Java提供Cloneable接口，为了在运行时通知Java虚拟机可以安全地在该类上使用clone()方法。而如果该类没有实现 Cloneable接口，则调用clone()方法会抛出 CloneNotSupportedException异常。一般情况下，如果使用clone()方法，则需满足以下条件。
- 对任何对象o，都有o.clone() != o。换言之，克隆对象与原型对象不是同一个对象。
- 对任何对象o，都有o.clone().getClass() == o.getClass()。换言之，克隆对象与原型对象的类型一样。
- 如果对象o的equals()方法定义恰当，则o.clone().equals(o)应当成立。

clone()的方式是浅拷贝。为了使用深拷贝通常使用序列化的方式。

优点：
- 基于二进制流的对象复制比new更快
- 可以保存对象状态

缺点：
- 每个类都要配置一个clone方法
- clone方法位于类的内部，当对已有类进行改造的时候，需要修改代码，违背了开闭原则
- 当实现深克隆时，需要编写较为复杂的代码，而且当对象之间存在多重嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来会比较麻烦

适用情况：
- 创建对象成本较大（例如，初始化时间长，占用CPU太多，或者占用网络资源太多等），需要优化资源
- 创建一个对象需要烦琐的数据准备或访问权限等，需要提高性能或者提高安全性
- 系统中大量使用该类对象，且各个调用者都需要给它的属性重新赋值

